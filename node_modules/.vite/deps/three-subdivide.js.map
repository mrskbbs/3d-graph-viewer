{
  "version": 3,
  "sources": ["../../three-subdivide/src/LoopSubdivision.js"],
  "sourcesContent": ["/**\n * @description Loop Subdivision Surface\n * @about       Smooth subdivision surface modifier for use with three.js BufferGeometry.\n * @author      Stephens Nunnally <@stevinz>\n * @license     MIT - Copyright (c) 2022 Stephens Nunnally\n * @source      https://github.com/stevinz/three-subdivide\n */\n/////////////////////////////////////////////////////////////////////////////////////\n//\n//  Functions\n//      modify              Applies Loop subdivision to BufferGeometry, returns new BufferGeometry\n//      edgeSplit           Splits all triangles at edges shared by coplanar triangles\n//      flat                One iteration of Loop subdivision, without point averaging\n//      smooth              One iteration of Loop subdivision, with point averaging\n//\n//  Info\n//      This modifier uses the Loop (Charles Loop, 1987) subdivision surface algorithm to smooth\n//      modern three.js BufferGeometry.\n//\n//      At one point, three.js included a subdivision surface modifier in the extended examples (see bottom\n//      of file for links), it was removed in r125. The modifier was originally based on the Catmull-Clark\n//      algorithm, which works best for geometry with convex coplanar n-gon faces. In three.js r60 the modifier\n//      was changed to utilize the Loop algorithm. The Loop algorithm was designed to work better with triangle\n//      based meshes.\n//\n//      The Loop algorithm, however, doesn't always provide uniform results as the vertices are\n//      skewed toward the most used vertex positions. A triangle based box (e.g. BoxGeometry for example) will\n//      tend to favor the corners. To alleviate this issue, this implementation includes an initial pass to split\n//      coplanar faces at their shared edges. It starts by splitting along the longest shared edge first, and then\n//      from that midpoint it splits to any remaining coplanar shared edges.\n//\n//      Also by default, this implementation inserts new uv coordinates, but does not average them using the Loop\n//      algorithm. In some cases (often in flat geometries) this will produce undesired results, a\n//      noticeable tearing will occur. In such cases, try passing 'uvSmooth' as true to enable uv averaging.\n//\n//  Note(s)\n//      - This modifier returns a new BufferGeometry instance, it does not dispose() of the old geometry.\n//\n//      - This modifier returns a NonIndexed geometry. An Indexed geometry can be created by using the\n//        BufferGeometryUtils.mergeVertices() function, see:\n//        https://threejs.org/docs/?q=buffer#examples/en/utils/BufferGeometryUtils.mergeVertices\n//\n//      - This modifier works best with geometry whose triangles share edges AND edge vertices. See diagram below.\n//\n//          OKAY          NOT OKAY\n//            O              O\n//           /|\\            / \\\n//          / | \\          /   \\\n//         /  |  \\        /     \\\n//        O---O---O      O---O---O\n//         \\  |  /        \\  |  /\n//          \\ | /          \\ | /\n//           \\|/            \\|/\n//            O              O\n//\n//  Reference(s)\n//      - Subdivision Surfaces\n//          https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/thesis-10.pdf\n//          https://en.wikipedia.org/wiki/Loop_subdivision_surface\n//          https://cseweb.ucsd.edu/~alchern/teaching/cse167_fa21/6-3Surfaces.pdf\n//\n//      - Original three.js SubdivisionModifier, r124 (Loop)\n//          https://github.com/mrdoob/three.js/blob/r124/examples/jsm/modifiers/SubdivisionModifier.js\n//\n//      - Original three.js SubdivisionModifier, r59 (Catmull-Clark)\n//          https://github.com/mrdoob/three.js/blob/r59/examples/js/modifiers/SubdivisionModifier.js\n//\n/////////////////////////////////////////////////////////////////////////////////////\n\nimport * as THREE from 'three';\n\n///// Constants\n\nconst POSITION_DECIMALS = 2;\n\n///// Local Variables\n\nconst _average = new THREE.Vector3();\nconst _center = new THREE.Vector3();\nconst _midpoint = new THREE.Vector3();\nconst _normal = new THREE.Vector3();\nconst _temp = new THREE.Vector3();\n\nconst _vector0 = new THREE.Vector3(); // .Vector4();\nconst _vector1 = new THREE.Vector3(); // .Vector4();\nconst _vector2 = new THREE.Vector3(); // .Vector4();\nconst _vec0to1 = new THREE.Vector3();\nconst _vec1to2 = new THREE.Vector3();\nconst _vec2to0 = new THREE.Vector3();\n\nconst _position = [\n    new THREE.Vector3(),\n    new THREE.Vector3(),\n    new THREE.Vector3(),\n];\n\nconst _vertex = [\n    new THREE.Vector3(),\n    new THREE.Vector3(),\n    new THREE.Vector3(),\n];\n\nconst _triangle = new THREE.Triangle();\n\n/////////////////////////////////////////////////////////////////////////////////////\n/////   Loop Subdivision Surface\n/////////////////////////////////////////////////////////////////////////////////////\n\n/** Loop subdivision surface modifier for use with modern three.js BufferGeometry */\nexport class LoopSubdivision {\n\n    /////////////////////////////////////////////////////////////////////////////////////\n    /////   Modify\n    ////////////////////\n\n    /**\n     * Applies Loop subdivision modifier to geometry\n     *\n     * @param {Object} bufferGeometry - Three.js geometry to be subdivided\n     * @param {Number} iterations - How many times to run subdividion\n     * @param {Object} params - Optional parameters object, see below\n     * @returns {Object} Returns new, subdivided, three.js BufferGeometry object\n     *\n     * Optional Parameters Object\n     * @param {Boolean} split - Should coplanar faces be divided along shared edges before running Loop subdivision?\n     * @param {Boolean} uvSmooth - Should UV values be averaged during subdivision?\n     * @param {Boolean} preserveEdges - Should edges / breaks in geometry be ignored during subdivision?\n     * @param {Boolean} flatOnly - If true, subdivision generates triangles, but does not modify positions\n     * @param {Number} maxTriangles - If geometry contains more than this many triangles, subdivision will not continue\n     * @param {Number} weight - How much to weigh favoring heavy corners vs favoring Loop's formula\n     */\n    static modify(bufferGeometry, iterations = 1, params = {}) {\n        if (arguments.length > 3) console.warn(`LoopSubdivision.modify() now uses a parameter object. See readme for more info!`);\n\n        if (typeof params !== 'object') params = {};\n\n        ///// Parameters\n        if (params.split === undefined) params.split = true;\n        if (params.uvSmooth === undefined) params.uvSmooth = false;\n        if (params.preserveEdges === undefined) params.preserveEdges = false;\n        if (params.flatOnly === undefined) params.flatOnly = false;\n        if (params.maxTriangles === undefined) params.maxTriangles = Infinity;\n        if (params.weight === undefined) params.weight = 1;\n        if (isNaN(params.weight) || !isFinite(params.weight)) params.weight = 1;\n        params.weight = Math.max(0, (Math.min(1, params.weight)));\n\n        ///// Geometries\n        if (! verifyGeometry(bufferGeometry)) return bufferGeometry;\n        let modifiedGeometry = bufferGeometry.clone();\n\n        ///// Presplit\n        if (params.split) {\n            const splitGeometry = LoopSubdivision.edgeSplit(modifiedGeometry)\n            modifiedGeometry.dispose();\n            modifiedGeometry = splitGeometry;\n        }\n\n        ///// Apply Subdivision\n        for (let i = 0; i < iterations; i++) {\n            let currentTriangles = modifiedGeometry.attributes.position.count / 3;\n            if (currentTriangles < params.maxTriangles) {\n                let subdividedGeometry;\n\n                // Subdivide\n                if (params.flatOnly) {\n                    subdividedGeometry = LoopSubdivision.flat(modifiedGeometry, params);\n                } else {\n                    subdividedGeometry = LoopSubdivision.smooth(modifiedGeometry, params);\n                }\n\n                // Copy and Resize Groups\n                modifiedGeometry.groups.forEach((group) => {\n                    subdividedGeometry.addGroup(group.start * 4, group.count * 4, group.materialIndex);\n                });\n\n                // Clean Up\n                modifiedGeometry.dispose();\n                modifiedGeometry = subdividedGeometry;\n            }\n        }\n\n        ///// Return New Geometry\n        return modifiedGeometry;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////\n    /////   Split Hypotenuse\n    ////////////////////\n\n    /**\n     * Applies one iteration of split subdivision. Splits all triangles at edges shared by coplanar triangles.\n     * Starts by splitting at longest shared edge, followed by splitting from that new center edge point to the\n     * center of any other shared edges.\n     */\n    static edgeSplit(geometry) {\n\n        ///// Geometries\n        if (! verifyGeometry(geometry)) return geometry;\n        const existing = (geometry.index !== null) ? geometry.toNonIndexed() : geometry.clone();\n        const split = new THREE.BufferGeometry();\n\n        ///// Attributes\n        const attributeList = gatherAttributes(existing);\n        const vertexCount = existing.attributes.position.count;\n        const posAttribute = existing.getAttribute('position');\n        const norAttribute = existing.getAttribute('normal');\n        const edgeHashToTriangle = {};\n        const triangleEdgeHashes = [];\n        const edgeLength = {};\n        const triangleExist = [];\n\n        ///// Edges\n        for (let i = 0; i < vertexCount; i += 3) {\n\n            // Positions\n            _vector0.fromBufferAttribute(posAttribute, i + 0);\n            _vector1.fromBufferAttribute(posAttribute, i + 1);\n            _vector2.fromBufferAttribute(posAttribute, i + 2);\n            _normal.fromBufferAttribute(norAttribute, i);\n            const vecHash0 = hashFromVector(_vector0);\n            const vecHash1 = hashFromVector(_vector1);\n            const vecHash2 = hashFromVector(_vector2);\n\n            // Verify Area\n            const triangleSize = _triangle.set(_vector0, _vector1, _vector2).getArea();\n            triangleExist.push(! fuzzy(triangleSize, 0));\n            if (! triangleExist[i / 3]) {\n                triangleEdgeHashes.push([]);\n                continue;\n            }\n\n            // Calculate Normals\n            calcNormal(_normal, _vector0, _vector1, _vector2);\n            const normalHash = hashFromVector(_normal);\n\n            // Vertex Hashes\n            const hashes = [\n                `${vecHash0}_${vecHash1}_${normalHash}`, // [0]: 0to1\n                `${vecHash1}_${vecHash0}_${normalHash}`, // [1]: 1to0\n                `${vecHash1}_${vecHash2}_${normalHash}`, // [2]: 1to2\n                `${vecHash2}_${vecHash1}_${normalHash}`, // [3]: 2to1\n                `${vecHash2}_${vecHash0}_${normalHash}`, // [4]: 2to0\n                `${vecHash0}_${vecHash2}_${normalHash}`, // [5]: 0to2\n            ];\n\n            // Store Edge Hashes\n            const index = i / 3;\n            for (let j = 0; j < hashes.length; j++) {\n                // Attach Triangle Index to Edge Hash\n                if (! edgeHashToTriangle[hashes[j]]) edgeHashToTriangle[hashes[j]] = [];\n                edgeHashToTriangle[hashes[j]].push(index);\n\n                // Edge Length\n                if (! edgeLength[hashes[j]]) {\n                    if (j === 0 || j === 1) edgeLength[hashes[j]] = _vector0.distanceTo(_vector1);\n                    if (j === 2 || j === 3) edgeLength[hashes[j]] = _vector1.distanceTo(_vector2);\n                    if (j === 4 || j === 5) edgeLength[hashes[j]] = _vector2.distanceTo(_vector0);\n                }\n            }\n\n            // Triangle Edge Reference\n            triangleEdgeHashes.push([ hashes[0], hashes[2], hashes[4] ]);\n        }\n\n        ///// Build Geometry, Set Attributes\n        attributeList.forEach((attributeName) => {\n            const attribute = existing.getAttribute(attributeName);\n            if (! attribute) return;\n            const floatArray = splitAttribute(attribute, attributeName);\n            split.setAttribute(attributeName, new THREE.BufferAttribute(floatArray, attribute.itemSize));\n        });\n\n        ///// Morph Attributes\n        const morphAttributes = existing.morphAttributes;\n        for (const attributeName in morphAttributes) {\n            const array = [];\n            const morphAttribute = morphAttributes[attributeName];\n\n            // Process Array of Float32BufferAttributes\n            for (let i = 0, l = morphAttribute.length; i < l; i++) {\n                if (morphAttribute[i].count !== vertexCount) continue;\n                const floatArray = splitAttribute(morphAttribute[i], attributeName, true);\n                array.push(new THREE.BufferAttribute(floatArray, morphAttribute[i].itemSize));\n            }\n            split.morphAttributes[attributeName] = array;\n        }\n        split.morphTargetsRelative = existing.morphTargetsRelative;\n\n        // Clean Up, Return New Geometry\n        existing.dispose();\n        return split;\n\n        // Loop Subdivide Function\n        function splitAttribute(attribute, attributeName, morph = false) {\n            const newTriangles = 4; /* maximum number of new triangles */\n            const arrayLength = (vertexCount * attribute.itemSize) * newTriangles;\n            const floatArray = new attribute.array.constructor(arrayLength);\n\n            const processGroups = (attributeName === 'position' && ! morph && existing.groups.length > 0);\n            let groupStart = undefined, groupMaterial = undefined;\n\n            let index = 0;\n            let skipped = 0;\n            let step = attribute.itemSize;\n            for (let i = 0; i < vertexCount; i += 3) {\n\n                // Verify Triangle is Valid\n                if (! triangleExist[i / 3]) {\n                    skipped += 3;\n                    continue;\n                }\n\n                // Get Triangle Points\n                _vector0.fromBufferAttribute(attribute, i + 0);\n                _vector1.fromBufferAttribute(attribute, i + 1);\n                _vector2.fromBufferAttribute(attribute, i + 2);\n\n                // Check for Shared Edges\n                const existingIndex = i / 3;\n                const edgeHash0to1 = triangleEdgeHashes[existingIndex][0];\n                const edgeHash1to2 = triangleEdgeHashes[existingIndex][1];\n                const edgeHash2to0 = triangleEdgeHashes[existingIndex][2];\n\n                const edgeCount0to1 = edgeHashToTriangle[edgeHash0to1].length;\n                const edgeCount1to2 = edgeHashToTriangle[edgeHash1to2].length;\n                const edgeCount2to0 = edgeHashToTriangle[edgeHash2to0].length;\n                const sharedCount = (edgeCount0to1 + edgeCount1to2 + edgeCount2to0) - 3;\n\n                // New Index (Before New Triangles, used for Groups)\n                const loopStartIndex = ((index * 3) / step) / 3;\n\n                // No Shared Edges\n                if (sharedCount === 0) {\n                    setTriangle(floatArray, index, step, _vector0, _vector1, _vector2); index += (step * 3);\n\n                // Shared Edges\n                } else {\n                    const length0to1 = edgeLength[edgeHash0to1];\n                    const length1to2 = edgeLength[edgeHash1to2];\n                    const length2to0 = edgeLength[edgeHash2to0];\n\n                    // Add New Triangle Positions\n                    if ((length0to1 > length1to2 || edgeCount1to2 <= 1) &&\n                        (length0to1 > length2to0 || edgeCount2to0 <= 1) && edgeCount0to1 > 1) {\n                        _center.copy(_vector0).add(_vector1).divideScalar(2.0);\n                        if (edgeCount2to0 > 1) {\n                            _midpoint.copy(_vector2).add(_vector0).divideScalar(2.0);\n                            setTriangle(floatArray, index, step, _vector0, _center, _midpoint); index += (step * 3);\n                            setTriangle(floatArray, index, step, _center, _vector2, _midpoint); index += (step * 3);\n                        } else {\n                            setTriangle(floatArray, index, step, _vector0, _center, _vector2); index += (step * 3);\n                        }\n                        if (edgeCount1to2 > 1) {\n                            _midpoint.copy(_vector1).add(_vector2).divideScalar(2.0);\n                            setTriangle(floatArray, index, step, _center, _vector1, _midpoint); index += (step * 3);\n                            setTriangle(floatArray, index, step, _midpoint, _vector2, _center); index += (step * 3);\n                        } else {\n                            setTriangle(floatArray, index, step, _vector1, _vector2, _center); index += (step * 3);\n                        }\n\n                    } else if ((length1to2 > length2to0 || edgeCount2to0 <= 1) && edgeCount1to2 > 1) {\n                        _center.copy(_vector1).add(_vector2).divideScalar(2.0);\n                        if (edgeCount0to1 > 1) {\n                            _midpoint.copy(_vector0).add(_vector1).divideScalar(2.0);\n                            setTriangle(floatArray, index, step, _center, _midpoint, _vector1); index += (step * 3);\n                            setTriangle(floatArray, index, step, _midpoint, _center, _vector0); index += (step * 3);\n                        } else {\n                            setTriangle(floatArray, index, step, _vector1, _center, _vector0); index += (step * 3);\n                        }\n                        if (edgeCount2to0 > 1) {\n                            _midpoint.copy(_vector2).add(_vector0).divideScalar(2.0);\n                            setTriangle(floatArray, index, step, _center, _vector2, _midpoint); index += (step * 3);\n                            setTriangle(floatArray, index, step, _midpoint, _vector0, _center); index += (step * 3);\n                        } else {\n                            setTriangle(floatArray, index, step, _vector2, _vector0, _center); index += (step * 3);\n                        }\n\n                    } else if (edgeCount2to0 > 1) {\n                        _center.copy(_vector2).add(_vector0).divideScalar(2.0);\n                        if (edgeCount1to2 > 1) {\n                            _midpoint.copy(_vector1).add(_vector2).divideScalar(2.0);\n                            setTriangle(floatArray, index, step, _vector2, _center, _midpoint); index += (step * 3);\n                            setTriangle(floatArray, index, step, _center, _vector1, _midpoint); index += (step * 3);\n                        } else {\n                            setTriangle(floatArray, index, step, _vector2, _center, _vector1); index += (step * 3);\n                        }\n                        if (edgeCount0to1 > 1) {\n                            _midpoint.copy(_vector0).add(_vector1).divideScalar(2.0);\n                            setTriangle(floatArray, index, step, _vector0, _midpoint, _center); index += (step * 3);\n                            setTriangle(floatArray, index, step, _midpoint, _vector1, _center); index += (step * 3);\n                        } else {\n                            setTriangle(floatArray, index, step, _vector0, _vector1, _center); index += (step * 3);\n                        }\n\n                    } else {\n                        setTriangle(floatArray, index, step, _vector0, _vector1, _vector2); index += (step * 3);\n                    }\n                }\n\n                // Process Groups\n                if (processGroups) {\n                    existing.groups.forEach((group) => {\n                        if (group.start === (i - skipped)) {\n                            if (groupStart !== undefined && groupMaterial !== undefined) {\n                                split.addGroup(groupStart, loopStartIndex - groupStart, groupMaterial);\n                            }\n                            groupStart = loopStartIndex;\n                            groupMaterial = group.materialIndex;\n                        }\n                    });\n                }\n\n                // Reset Skipped Triangle Counter\n                skipped = 0;\n            }\n\n            // Resize Array\n            const reducedCount = (index * 3) / step;\n            const reducedArray = new attribute.array.constructor(reducedCount);\n            for (let i = 0; i < reducedCount; i++) {\n                reducedArray[i] = floatArray[i];\n            }\n\n            // Final Group\n            if (processGroups && groupStart !== undefined && groupMaterial !== undefined) {\n                split.addGroup(groupStart, (((index * 3) / step) / 3) - groupStart, groupMaterial);\n            }\n\n            return reducedArray;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////\n    /////   Flat\n    ////////////////////\n\n    /** Applies one iteration of Loop (flat) subdivision (1 triangle split into 4 triangles) */\n    static flat(geometry, params = {}) {\n\n        ///// Geometries\n        if (! verifyGeometry(geometry)) return geometry;\n        const existing = (geometry.index !== null) ? geometry.toNonIndexed() : geometry.clone();\n        const loop = new THREE.BufferGeometry();\n\n        ///// Attributes\n        const attributeList = gatherAttributes(existing);\n        const vertexCount = existing.attributes.position.count;\n\n        ///// Build Geometry\n        attributeList.forEach((attributeName) => {\n            const attribute = existing.getAttribute(attributeName);\n            if (! attribute) return;\n\n            loop.setAttribute(attributeName, LoopSubdivision.flatAttribute(attribute, vertexCount, params));\n        });\n\n        ///// Morph Attributes\n        const morphAttributes = existing.morphAttributes;\n        for (const attributeName in morphAttributes) {\n            const array = [];\n            const morphAttribute = morphAttributes[attributeName];\n\n            // Process Array of Float32BufferAttributes\n\t\t\tfor (let i = 0, l = morphAttribute.length; i < l; i++) {\n                if (morphAttribute[i].count !== vertexCount) continue;\n                array.push(LoopSubdivision.flatAttribute(morphAttribute[i], vertexCount, params));\n            }\n            loop.morphAttributes[attributeName] = array;\n        }\n        loop.morphTargetsRelative = existing.morphTargetsRelative;\n\n        ///// Clean Up\n        existing.dispose();\n        return loop;\n    }\n\n    static flatAttribute(attribute, vertexCount, params = {}) {\n        const newTriangles = 4;\n        const arrayLength = (vertexCount * attribute.itemSize) * newTriangles;\n        const floatArray = new attribute.array.constructor(arrayLength);\n\n        let index = 0;\n        let step = attribute.itemSize;\n        for (let i = 0; i < vertexCount; i += 3) {\n\n            // Original Vertices\n            _vector0.fromBufferAttribute(attribute, i + 0);\n            _vector1.fromBufferAttribute(attribute, i + 1);\n            _vector2.fromBufferAttribute(attribute, i + 2);\n\n            // Midpoints\n            _vec0to1.copy(_vector0).add(_vector1).divideScalar(2.0);\n            _vec1to2.copy(_vector1).add(_vector2).divideScalar(2.0);\n            _vec2to0.copy(_vector2).add(_vector0).divideScalar(2.0);\n\n            // Add New Triangle Positions\n            setTriangle(floatArray, index, step, _vector0, _vec0to1, _vec2to0); index += (step * 3);\n            setTriangle(floatArray, index, step, _vector1, _vec1to2, _vec0to1); index += (step * 3);\n            setTriangle(floatArray, index, step, _vector2, _vec2to0, _vec1to2); index += (step * 3);\n            setTriangle(floatArray, index, step, _vec0to1, _vec1to2, _vec2to0); index += (step * 3);\n        }\n\n        return new THREE.BufferAttribute(floatArray, attribute.itemSize);\n    }\n\n    /////////////////////////////////////////////////////////////////////////////////////\n    /////   Smooth\n    ////////////////////\n\n    /** Applies one iteration of Loop (smooth) subdivision (1 triangle split into 4 triangles) */\n    static smooth(geometry, params = {}) {\n\n        if (typeof params !== 'object') params = {};\n\n        ///// Parameters\n        if (params.uvSmooth === undefined) params.uvSmooth = false;\n        if (params.preserveEdges === undefined) params.preserveEdges = false;\n\n        ///// Geometries\n        if (! verifyGeometry(geometry)) return geometry;\n        const existing = (geometry.index !== null) ? geometry.toNonIndexed() : geometry.clone();\n        const flat = LoopSubdivision.flat(existing, params);\n        const loop = new THREE.BufferGeometry();\n\n        ///// Attributes\n        const attributeList = gatherAttributes(existing);\n        const vertexCount = existing.attributes.position.count;\n        const posAttribute = existing.getAttribute('position');\n        const flatPosition = flat.getAttribute('position');\n        const hashToIndex = {};             // Position hash mapped to index values of same position\n        const existingNeighbors = {};       // Position hash mapped to existing vertex neighbors\n        const flatOpposites = {};           // Position hash mapped to new edge point opposites\n        const existingEdges = {};\n\n        function addNeighbor(posHash, neighborHash, index) {\n            if (! existingNeighbors[posHash]) existingNeighbors[posHash] = {};\n            if (! existingNeighbors[posHash][neighborHash]) existingNeighbors[posHash][neighborHash] = [];\n            existingNeighbors[posHash][neighborHash].push(index);\n        }\n\n        function addOpposite(posHash, index) {\n            if (! flatOpposites[posHash]) flatOpposites[posHash] = [];\n            flatOpposites[posHash].push(index);\n        }\n\n        function addEdgePoint(posHash, edgeHash) {\n            if (! existingEdges[posHash]) existingEdges[posHash] = new Set();\n            existingEdges[posHash].add(edgeHash);\n        }\n\n        ///// Existing Vertex Hashes\n        for (let i = 0; i < vertexCount; i += 3) {\n            const posHash0 = hashFromVector(_vertex[0].fromBufferAttribute(posAttribute, i + 0));\n            const posHash1 = hashFromVector(_vertex[1].fromBufferAttribute(posAttribute, i + 1));\n            const posHash2 = hashFromVector(_vertex[2].fromBufferAttribute(posAttribute, i + 2));\n\n            // Neighbors (of Existing Geometry)\n            addNeighbor(posHash0, posHash1, i + 1);\n            addNeighbor(posHash0, posHash2, i + 2);\n            addNeighbor(posHash1, posHash0, i + 0);\n            addNeighbor(posHash1, posHash2, i + 2);\n            addNeighbor(posHash2, posHash0, i + 0);\n            addNeighbor(posHash2, posHash1, i + 1);\n\n            // Opposites (of new FlatSubdivided vertices)\n            _vec0to1.copy(_vertex[0]).add(_vertex[1]).divideScalar(2.0);\n            _vec1to2.copy(_vertex[1]).add(_vertex[2]).divideScalar(2.0);\n            _vec2to0.copy(_vertex[2]).add(_vertex[0]).divideScalar(2.0);\n            const hash0to1 = hashFromVector(_vec0to1);\n            const hash1to2 = hashFromVector(_vec1to2);\n            const hash2to0 = hashFromVector(_vec2to0);\n            addOpposite(hash0to1, i + 2);\n            addOpposite(hash1to2, i + 0);\n            addOpposite(hash2to0, i + 1);\n\n            // Track Edges for 'edgePreserve'\n            addEdgePoint(posHash0, hash0to1);\n            addEdgePoint(posHash0, hash2to0);\n            addEdgePoint(posHash1, hash0to1);\n            addEdgePoint(posHash1, hash1to2);\n            addEdgePoint(posHash2, hash1to2);\n            addEdgePoint(posHash2, hash2to0);\n        }\n\n        ///// Flat Position to Index Map\n        for (let i = 0; i < flat.attributes.position.count; i++) {\n            const posHash = hashFromVector(_temp.fromBufferAttribute(flatPosition, i));\n            if (! hashToIndex[posHash]) hashToIndex[posHash] = [];\n            hashToIndex[posHash].push(i);\n        }\n\n        ///// Build Geometry, Set Attributes\n        attributeList.forEach((attributeName) => {\n            const existingAttribute = existing.getAttribute(attributeName);\n            const flattenedAttribute = flat.getAttribute(attributeName);\n            if (existingAttribute === undefined || flattenedAttribute === undefined) return;\n\n            const floatArray = subdivideAttribute(attributeName, existingAttribute, flattenedAttribute);\n            loop.setAttribute(attributeName, new THREE.BufferAttribute(floatArray, flattenedAttribute.itemSize));\n        });\n\n        ///// Morph Attributes\n        const morphAttributes = existing.morphAttributes;\n        for (const attributeName in morphAttributes) {\n            const array = [];\n            const morphAttribute = morphAttributes[attributeName];\n\n            // Process Array of Float32BufferAttributes\n            for (let i = 0, l = morphAttribute.length; i < l; i++) {\n                if (morphAttribute[i].count !== vertexCount) continue;\n                const existingAttribute = morphAttribute[i];\n                const flattenedAttribute = LoopSubdivision.flatAttribute(morphAttribute[i], morphAttribute[i].count, params)\n\n                const floatArray = subdivideAttribute(attributeName, existingAttribute, flattenedAttribute);\n                array.push(new THREE.BufferAttribute(floatArray, flattenedAttribute.itemSize));\n            }\n            loop.morphAttributes[attributeName] = array;\n        }\n        loop.morphTargetsRelative = existing.morphTargetsRelative;\n\n        ///// Clean Up\n        flat.dispose();\n        existing.dispose();\n        return loop;\n\n        //////////\n\n        // Loop Subdivide Function\n        function subdivideAttribute(attributeName, existingAttribute, flattenedAttribute) {\n            const arrayLength = (flat.attributes.position.count * flattenedAttribute.itemSize);\n            const floatArray = new existingAttribute.array.constructor(arrayLength);\n\n            // Process Triangles\n            let index = 0;\n            for (let i = 0; i < flat.attributes.position.count; i += 3) {\n\n                // Process Triangle Points\n                for (let v = 0; v < 3; v++) {\n\n                    if (attributeName === 'uv' && ! params.uvSmooth) {\n\n                        _vertex[v].fromBufferAttribute(flattenedAttribute, i + v);\n\n                    } else if (attributeName === 'normal') { // && params.normalSmooth) {\n\n                        _position[v].fromBufferAttribute(flatPosition, i + v);\n                        const positionHash = hashFromVector(_position[v]);\n                        const positions = hashToIndex[positionHash];\n\n                        const k = Object.keys(positions).length;\n                        const beta = 0.75 / k;\n                        const startWeight = 1.0 - (beta * k);\n\n                        _vertex[v].fromBufferAttribute(flattenedAttribute, i + v);\n                        _vertex[v].multiplyScalar(startWeight);\n\n                        positions.forEach(positionIndex => {\n                            _average.fromBufferAttribute(flattenedAttribute, positionIndex);\n                            _average.multiplyScalar(beta);\n                            _vertex[v].add(_average);\n                        });\n\n\n                    } else { // 'position', 'color', etc...\n\n                        _vertex[v].fromBufferAttribute(flattenedAttribute, i + v);\n                        _position[v].fromBufferAttribute(flatPosition, i + v);\n\n                        const positionHash = hashFromVector(_position[v]);\n                        const neighbors = existingNeighbors[positionHash];\n                        const opposites = flatOpposites[positionHash];\n\n                        ///// Adjust Source Vertex\n                        if (neighbors) {\n\n                            // Check Edges have even Opposite Points\n                            if (params.preserveEdges) {\n                                const edgeSet = existingEdges[positionHash];\n                                let hasPair = true;\n                                for (const edgeHash of edgeSet) {\n                                    if (flatOpposites[edgeHash].length % 2 !== 0) hasPair = false;\n                                }\n                                if (! hasPair) continue;\n                            }\n\n                            // Number of Neighbors\n                            const k = Object.keys(neighbors).length;\n\n                            ///// Loop's Formula\n                            const beta = 1 / k * ((5/8) - Math.pow((3/8) + (1/4) * Math.cos(2 * Math.PI / k), 2));\n\n                            ///// Warren's Formula\n                            // const beta = (k > 3) ? 3 / (8 * k) : ((k === 3) ? 3 / 16 : 0);\n\n                            ///// Stevinz' Formula\n                            // const beta = 0.5 / k;\n\n                            ///// Corners\n                            const heavy = (1 / k) / k;\n\n                            ///// Interpolate Beta -> Heavy\n                            const weight = lerp(heavy, beta, params.weight);\n\n                            ///// Average with Neighbors\n                            const startWeight = 1.0 - (weight * k);\n                            _vertex[v].multiplyScalar(startWeight);\n\n                            for (let neighborHash in neighbors) {\n                                const neighborIndices = neighbors[neighborHash];\n\n                                _average.set(0, 0, 0);\n                                for (let j = 0; j < neighborIndices.length; j++) {\n                                    _average.add(_temp.fromBufferAttribute(existingAttribute, neighborIndices[j]));\n                                }\n                                _average.divideScalar(neighborIndices.length);\n\n                                _average.multiplyScalar(weight);\n                                _vertex[v].add(_average);\n                            }\n\n                        ///// Newly Added Edge Vertex\n                        } else if (opposites && opposites.length === 2) {\n                            const k = opposites.length;\n                            const beta = 0.125; /* 1/8 */\n                            const startWeight = 1.0 - (beta * k);\n                            _vertex[v].multiplyScalar(startWeight);\n\n                            opposites.forEach(oppositeIndex => {\n                                _average.fromBufferAttribute(existingAttribute, oppositeIndex);\n                                _average.multiplyScalar(beta);\n                                _vertex[v].add(_average);\n                            });\n                        }\n                    }\n                }\n\n                // Add New Triangle Position\n                setTriangle(floatArray, index, flattenedAttribute.itemSize, _vertex[0], _vertex[1], _vertex[2]);\n                index += (flattenedAttribute.itemSize * 3);\n            }\n\n            return floatArray;\n        }\n\n    }\n\n}\n\n/////////////////////////////////////////////////////////////////////////////////////\n/////   Local Functions, Hash\n/////////////////////////////////////////////////////////////////////////////////////\n\nconst _positionShift = Math.pow(10, POSITION_DECIMALS);\n\n/** Compares two numbers to see if they're almost the same */\nfunction fuzzy(a, b, tolerance = 0.00001) {\n    return ((a < (b + tolerance)) && (a > (b - tolerance)));\n}\n\n/** Generates hash strong from Number */\nfunction hashFromNumber(num, shift = _positionShift) {\n    let roundedNumber = round(num * shift);\n    if (roundedNumber == 0) roundedNumber = 0; /* prevent -0 (signed 0 can effect Math.atan2(), etc.) */\n    return `${roundedNumber}`;\n}\n\n/** Generates hash strong from Vector3 */\nfunction hashFromVector(vector, shift = _positionShift) {\n    return `${hashFromNumber(vector.x, shift)},${hashFromNumber(vector.y, shift)},${hashFromNumber(vector.z, shift)}`;\n}\n\nfunction lerp(x, y, t) {\n    return (1 - t) * x + t * y;\n}\n\nfunction round(x) {\n    return (x + ((x > 0) ? 0.5 : -0.5)) << 0;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////\n/////   Local Functions, Geometry\n/////////////////////////////////////////////////////////////////////////////////////\n\nfunction calcNormal(target, vec1, vec2, vec3) {\n    _temp.subVectors(vec1, vec2);\n    target.subVectors(vec2, vec3);\n    target.cross(_temp).normalize();\n}\n\nfunction gatherAttributes(geometry) {\n    const desired = [ 'position', 'normal', 'uv' ];\n    const contains = Object.keys(geometry.attributes);\n    const attributeList = Array.from(new Set(desired.concat(contains)));\n    return attributeList;\n}\n\nfunction setTriangle(positions, index, step, vec0, vec1, vec2) {\n    if (step >= 1) {\n        positions[index + 0 + (step * 0)] = vec0.x;\n        positions[index + 0 + (step * 1)] = vec1.x;\n        positions[index + 0 + (step * 2)] = vec2.x;\n    }\n    if (step >= 2) {\n        positions[index + 1 + (step * 0)] = vec0.y;\n        positions[index + 1 + (step * 1)] = vec1.y;\n        positions[index + 1 + (step * 2)] = vec2.y;\n    }\n    if (step >= 3) {\n        positions[index + 2 + (step * 0)] = vec0.z;\n        positions[index + 2 + (step * 1)] = vec1.z;\n        positions[index + 2 + (step * 2)] = vec2.z;\n    }\n    if (step >= 4) {\n        positions[index + 3 + (step * 0)] = vec0.w;\n        positions[index + 3 + (step * 1)] = vec1.w;\n        positions[index + 3 + (step * 2)] = vec2.w;\n    }\n}\n\nfunction verifyGeometry(geometry) {\n    if (geometry === undefined) {\n        console.warn(`LoopSubdivision: Geometry provided is undefined`);\n        return false;\n    }\n\n    if (! geometry.isBufferGeometry) {\n        console.warn(`LoopSubdivision: Geometry provided is not 'BufferGeometry' type`);\n        return false;\n    }\n\n    if (geometry.attributes.position === undefined) {\n        console.warn(`LoopSubdivision: Geometry provided missing required 'position' attribute`);\n        return false;\n    }\n\n    if (geometry.attributes.normal === undefined) {\n        geometry.computeVertexNormals();\n    }\n    return true;\n}\n"],
  "mappings": "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",
  "names": []
}
